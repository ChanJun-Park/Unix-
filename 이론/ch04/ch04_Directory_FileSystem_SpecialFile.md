# Ch04 Directory FileSystem SpecialFile

## 4.1 서론

UNIX File System은 저장장치에 저장되어 있는 파일들에 대한 계층적 구조를 형성한다. 파일들에 대한 계층적 구조는 디렉토리와 서브 디렉토리 구조를 통해서 구현된다. 파일들은 특정 디렉토리에 포함되며 디렉토리들은 트리 구조를 그리며 서로를 포함한다. 이 트리 구조의 맨 꼭대기에는 '/'로 표시되는 루트 디렉토리가 존재한다.

파일 시스템은 디스크 또는 파티션 단위로 저장될 수 있다. 파일 시스템을 이루는 논리적인 디스크 블록은 다음과 같은 구조를 가지고 있다.(일반적으로 디스크 블록은 512 * 2의 배수 바이트로 형성된다)

- 부트 블록(Boot block) : 파티션의 맨 앞쪽의 블록. UNIX 시스템을 시작하는 코드가 담겨있다. 맨 처음 컴퓨터를 부팅할 경우 이 블록에 저장되어 있는 코드가 로드되어 실행된다.
- 수퍼 블록(Super Block) : 파일 시스템에 대한 전반적인 정보가 저장되는 블록이다. 이 블록에는 전체 블록 사이즈, inode 블록 개수, free inode 리스트에 대한 포인터, free block 리스트에 대한 포인터, 데이터 저장 블록 개수 등등의 정보가 담긴다.
- inode 블록 : 파일에 대한 inode 정보를 담고 있는 블록이다. 하나의 파일은 하나의 inode와 대응한다. 이 inode 구조에는 해당 파일에 대한 link count나 파일이 저장되어 있는 disk 블록의 위치 등을 저장하고 있다.
- data block : 일반 파일들이 실제로 저장되는 위치이다.

## 4.2 디렉토리 : 사용자 관점

사용자 입장에서 디렉토리는 파일들을 그룹화하여 관리하는 도구를 제공한다.

## 4.3 디렉토리의 구현

디렉토리 또한 하나의 파일이다. 이 파일에는 디렉토리가 포함하고 있는 파일들의 이름과 그 파일들에 대한 inode 번호가 담긴 엔트리들을 관리하고 있다.

### 4.3.1 link와 unlink의 재고찰

앞선 장에서 link와 unlink를 통해서 파일에 대한 hard link를 생성하고 지우는 방법을 알아보았다. 이들 시스템 호출은 hard link를 디렉토리 엔트리에 추가하고, 제거하는 시스템 호출이라고 할 수 있다. 따라서 디렉토리 파일에 대한 write permission이 있는 프로세스만이 해당 경로에 hard link를 생성하거나 제거할 수 있다.

### 4.3.2 점과 이중점

디렉토리 파일 내에는 특별한 파일에 대한 엔트리가 기본적으로 들어있다. 점(.)으로 표시되는 파일에 대한 엔트리는 현재 디렉토리 파일에 대한 엔트리를 나타낸다. 이중점(..)으로 표시되는 파일에 대한 엔트리는 디렉토리 계층 구조상 현재 디렉토리의 부모 디렉토리 파일에 대한 엔트리를 나타낸다.

### 4.3.3 디렉토리 허가

디렉토리도 하나의 파일이기 때문이 파일에 대한 permission이 존재한다. 그러나 이 permission은 일반 파일과는 의미가 다르다.

- read permission : 디렉토리 파일 내에 있는 엔트리들을 리스트 할 수 있는지 여부이다. 쉘 프로그램에서는 ls 명령어들 통해서 디렉토리 내의 파일들을 확인할 수 있는지에 대한 여부를 뜻한다.
- write permission : 디렉토리에 새로운 파일을 추가하거나, 제거할 수 있는지 여부를 뜻한다.
- execute permission : 쉘 프로그램에서 해당 디렉토리를 현재 작업 디렉토리로 설정할 수 있는지 여부이다. 쉘 프로그램이 현재 작업디렉토리를 특정 디렉토리로 설정하기 위해서는 그 디렉토리에서 루트까지 경로 상에 존재하는 모든 조상 디렉토리들에 대한 execute permission이 있어야한다.

## 4.4 디렉토리와 프로그래밍

### 4.4.1 디렉토리의 생성 및 제거

디렉토리는 mkdir과 rmdir 명령어를 통해서 생성하고 제거할 수 있다.

```c
int mkdir(const char * pathname);
```

역시 디렉토리를 생성하는 프로세스는 생성된 디렉토리가 저장될 부모 디렉토리에 대한 write permission이 존재해야 한다.

```c
int rmdir(const char * pathname);
```

### 4.4.2 디렉토리를 열기 및 닫기

디렉토리 역시 파일이기 때문에 파일에 대한 open, read, write 호출이 가능한지 궁금할 것이다. read 호출은 가능할 수 있어도, open, write 호출은 가능하지 않다. 디렉토리 파일을 열고 닫기 위해서는 특별한 시스템 호출을 사용해야 한다.

```c
DIR* opendir(const char * pathname);
```

이 시스템 호출은 디렉토리 파일에 대한 경로 이름을 전달 받고, DIR 구조체 포인터를 반환한다. 이는 파일을 여는 표준 라이브러리 루틴 `fopen()`이 파일 구조체 포인터를 반환하는 것과 비슷하다. 커널은 디렉토리에 대한 스트림을 형성하고, 이 스트림에 대한 접근을 DIR 구조체 포인터를 통해서 할 수 있다.

열려진 디렉토리 파일을 닫기 위해서는 closedir 시스템호출을 사용할 수 있다.

```c
int closedir(DIR* dir);
```

### 4.4.3 디렉토리를 읽기 : readdir과 rewinddir

디렉토리를 읽는 시스템 호출을 설명하기 전에 이들 정보가 저장될 구조체를 소개한다. struct dirent 구조체는 다음과 같은 필드를 가지고 있다.

- ino_t ino
- char * filename

```c
int readdir(DIR* dir, struct dirent * d);
```

`readdir` 시스템 호출은 디렉토리가 저장하고 있는 하나의 엔트리 정보를 인자로 전달한 struct dirent \* d 가 가리키고 있는 주소에 저장한다. 이 함수를 호출할 때마다, 다음 디렉토리 엔트리 정보가 struct dirent \* d에 저장되며 더이상 읽어들일 엔트리가 없으면 -1을 반환한다.

다시 처음의 디렉토리 엔트리부터 읽어들이기 위해서 `rewinddir` 시스템 호출을 사용할 수 있다.

```c
int rewinddir(DIR* dir);
```

### 4.4.4 현재 작업 디렉토리

쉘 프로그램을 보면 $기호 앞에 현재 쉘 명령어가 적용될 디렉토리를 보여준다. 쉘 프로그램에서 실행 파일을 입력하거나, 명령어를 입력하면 기본적으로 쉘 프로그램이 실행되고 있는 위치를 기반으로 실행된다. 이러한 디렉토리 경로를 현재 작업 디렉토리(current working directory, cwd)라고 한다. cwd는 또한 상대적 경로를 계산하는 기준을 제공한다. 점(.) 기호는 현재 작업 디렉토리를 나타내며, 이중점(..)은 현재 작업 디렉토리의 부모 디렉토리를 나타내게 된다.

쉘 프로그램 뿐만 아니라 실행되는 모든 프로세스는 자신만의 cwd를 가지게 된다. cwd를 통해서 파일에 접근하는 상대 경로, 시스템 호출을 적용하는 경로를 계산하게 된다.

### 4.4.5 chdir에 의한 디렉토리 변경

프로세스의 현재 작업 디렉토리를 변경하기 위해서는 `chdir` 시스템 호출을 사용할 수 있다.

```c
int chdir(const char * pathname);
```

chdir 명령어를 통해서 현재 작업 디렉토리를 변경하기 위해서는 변경된 작업디렉토리의 경로상에 존재하는 모든 디렉토리에 대한 execute permission을 가지고 있어야 한다.

### 4.4.6 현재 작업 디렉토리의 이름 찾기

현재 프로세스가 수행되고 있는 디렉토리의 이름은 다음 시스템 호출로 구할 수 있다.

```c
int getcwd(char * pathname);
```

### 4.4.7 디렉토리 트리의 산책

## 4.5 UNIX 화일 시스템

### 4.5.1 캐슁 : sync와 fsync

UNIX에서는 파일에 대한 I/O를 곧바로 디스크에 수행하지 않고 메모리 버퍼에 임시로 저장해둘 수 있다. 따라서 프로그램 수행의 한 시점에서 디스크 파일에 저장되어 있는 내용과 프로세스에서 출력했던 내용이 일치하지 않을 수 있다. 현재 파일로 출력했던 내용을 곧바로 디스크에 쓰기 위해서는 다음 시스템 호출을 이용할 수 있다.

```c
int sync(const char * pathname);
int fsync(int filedes);
```

## 4.6 UNIX 장치 화일

### 4.6.1 블록과 문자 장치 화일

### 4.6.2 stat 구조의 재고찰

### 4.6.3 화일 시스템 정보

### 4.6.4 화일과 디렉토리의 제한: pathconf와 fpathconf
