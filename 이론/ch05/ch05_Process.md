# Ch05 Process

## 5.10 프로세스 속성

UNIX 프로세스는 프로세스 수행 및 스케줄링, 파일 시스템의 보안 유지 등을 시스템이 제어하기 위해서 몇가지 속성을 가지고 있다.

### 5.10.1 프로세스 식별번호

프로세스는 한 시점에서 그 프로세스를 유일하게 식별하는 번호(음이 아닌 정수)를 커널로부터 부여받는다. 이를 프로세스 식별번호(process id)라고 한다. 시스템은 특수 프로세스를 위해서 프로세스 식별번호 0과 1을 유보해둔다. 프로세스 식별번호 0번은 swapper 프로세스(스케줄러), 1번은 init 프로세스이다. init 프로세스는 해당 프로세스에 의해서 직, 간접적으로 실행되는 모든 프로세스의 조상이다.

프로세스 식별 번호는 다음과 같은 시스템 호출을 통해서 구할 수 있다.

```c
#include <unistd.h>
#include <sys/types.h>

pid_t getpid(void);
```

부모 프로세스의 식별 번호는 다음과 같은 시스템 호출을 통해서 구할 수 있다.

```c
#include <unistd.h>
#include <sys/types.h>

pid_t getppid(void);
```

### 5.10.2 프로세스 그룹과 프로세스 그룹 식별번호

UNIX에서는 유용하게도 프로세스끼리 그룹을 형성할 수 있으며, 커널에 의해서 이러한 프로세스 그룹을 식별하는 pid_t 타입의 정수를 부여받는다. 이러한 정수를 프로세스 그룹 식별번호(process group id)라고 한다. 프로세스가 그룹을 형성하면 이 그룹의 프로세스들에게 6장에서 배울 시그널을 통해서 한번에 특정 신호를 전달할 수 있게 된다.

최초에 프로세스가 fork에 의해서 생성되면 자식 프로세스는 부모 프로세스의 프로세스 그룹 식별번호를 물려받는다. 기본적으로 자식 프로세스는 부모 프로세스와 동일한 그룹에 속하게 된다. 프로세스 식별번호와 프로세스 그룹 식별번호가 동일한 경우가 있다. 이런 프로세스를 그 그룹의 리더(Leader)라고 한다.

현재 프로세스의 프로세스 그룹 식별번호는 다음과 같은 시스템 호출을 통해서 구할 수 있다.

```c
#include <unistd.h>
#include <sys/types.h>

pid_t getpgrp(void);
```

또한 프로세스는 자신의 프로세스 그룹 아이디를 다시 설정해서 새로운 그룹을 형성할수도 있다. 프로세스 그룹 아이디를 변경하기 위해서 다음과 같은 시스템 호출을 사용할 수 있다.

### 5.10.3 프로세스 그룹의 변경

작업 제어(job control)를 지원하는 UNIX 쉘에서 한 프로세스가 새로운 프로세스 그룹에 속하기를 원할 때가 있다. 작업 제어는 쉘이 여러개의 프로세스 그룹들을 시작할 수 있게 하고, 어느 프로세스 그룹이 foreground에서 실행될지, 어느 프로세스 그룹이 background에서 실행될지를 결정할 수 있다. 작업 제어는 시그널의 사용을 통해 조작된다.

한 프로세스는 setpgid를 통해서 새로운 프로세스 그룹에 들어가거나, 새로운 그룹을 생성할 수 있다.

```c
#include <unistd.h>
#include <sys/types.h>

int setpgid(pid_t pid, pid_t pgid);
```

위 시스템 콜은 pid에 대응하는 프로세스에 대해서 해당 프로세스의 프로세스 그룹 식별번호를 pgid로 설정한다. pid 값이 0이라면 이 시스템 콜을 호출하는 프로세스가 사용된다. pid와 pgid가 동일하다면 새로운 프로세스 그룹이 생성되고, pid에 대응하는 프로세스는 이 그룹의 리더가 된다(pgid 값이 pid와 동일하게 된다). pgid 값이 0이 되면 pid값이 대신 사용된다. 오류시에는 -1을 반환한다.

인자로 0을 전달하게 되면 이 시스템 콜을 호출한 프로세스가 새로운 그룹을 생성하고 그 그룹의 리더가 된다.

### 5.10.4 세션과 세션 식별 번호

프로세스의 그룹은 또한 하나의 세션에 속할 수 있다. 한 세션은 명령어를 처리하는 하나의 제어 단말기(Controlling Terminal)에 대응하는 개념이다. 전형적으로 한 세션은 제어 단말기의 foreground에서 실행되는 프로세스 그룹과 background에서 실행되는 프로세스 그룹의 집합체이다. 세션에도 역시 세션을 식별할 수 있는 pid_t 타입의 세션 식별 번호(Session id)가 부여되어 있다.

한 프로세스는 자신이 현재 속해있는 세션의 식별번호를 다음과 같이 getsid() 함수를 호출하여 얻을 수 있다.

```c
#include <unistd.h>
#include <sys/types.h>

pid_t getsid(pid_t pid);
```

pid에 의해서 식별되는 프로세스의 세션 식별번호가 반환된다. 만약 pid값이 0이라면 호출하는 프로세스의 세션 식별번호가 반환된다.

세션을 활용하는 방법 중 하나는 한 프로세스를 데몬 프로세스로 만드는 것이 있다. 한 프로세스의 세션 id를 재설정하여 현재 세션과 관련된 제어 단말기를 사용하지 않도록 하면, 이 프로세스는 백그라운드에서 단말기에 특별한 출력 없이 실행되게 된다. 백그라운드에서 실행되는 이러한 프로세스를 데몬 프로세스라고 한다.

프로세스의 세션을 제어 단말기를 갖지 않는 새로운 세션으로 바꾸어 데몬을 만들기 위해선 setsid 시스템 콜을 이용할 수 있다.

```c
#include <sys/types.h>
#include <unistd.h>

pid_t setsid(void);
```

이 시스템 콜을 호출하는 프로세스는 한 프로세스 그룹의 리더가 되서는 안된다. 이 경우 -1을 반환하게 된다. 한 그룹의 리더가 아닌 프로세스가 위 시스템 콜을 호출하면, 새로운 프로세스 그룹과 프로세스 세션이 생성되고, 호출 프로세스의 식별번호가 그룹 식별번호와 세션 식별번호로 설정된다. 이제 이 프로세스는 새로 만들어진 그룹과 세션의 유일한 프로세스가 되며, 제어 단말기를 갖지 않는 데몬 프로세스가 된다.

### 5.10.5 환경

환경변수란 마지막에 널 포인터가 저장된 문자열들의 배열 형태이다. 각 문자열은 보통 name=value와 같은 형태를 띈다. 이는 프로세스가 실행하는 프로그램이 저장된 위치(HOME, path)와 같은 정보를 가지고 있다.

프로세스의 main 함수에서 argc와 argv 에 더하여 envp라는 세번째 매개변수를 첨가함으로써, 프로세스의 환경을 직접 사용할 수 있다.

```c
int main(int argc, char** argv, char** envp)
```

프로세스는 기본적으로 자신을 생성한 프로세스의 환경 변수값을 물려받는다.

이러한 자식프로세스에게 전달한 환경변수를 변경하기 위해서는 execle, execve 함수를 사용할 수 있다.

> 예제

```c
int main()
{
    char *argv[2], *envp[3];

    argv[0] = "showmyenv";
    argv[1] = (char *)0;

    envp[0] = "foo=bar";
    envp[1] = "bar=foo";
    envp[2] = (char *)0;

    execve("./showmyenv", argv, envp);

    perror("execve failed");

    return 0;
}
```

main 함수로 전달된 값을 사용할 수도 있지만, 전역적으로 선언된 환경변수 값을 사용할 수도 있다.

```c
extern char** envn;
```

전역적으로 선언된 환경 변수 값에서 특정한 부분을 읽는데에 다음과 같은 라이브러리 함수를 이용할 수 있다.

```c
#include <stdlib.h>

char *getenv(const char *name);
```

위 함수는 name에 해당하는 환경 변수 문자열의 값 부분을 반환한다. 함수 호출에 실패하면 위 함수는 NULL 포인터를 반환한다.

> 예제

```c
#include <stdlib.h>
#include <stdio.h>

int main()
{
    printf("PATH=%s\n", getenv("PATH"));
    return 0;
}
```

getenv() 함수에 대응하여, 전역적으로 선언된 환경 변수 값을 putenv() 함수를 통해서 변경할 수 있다. 이 함수는 프로세스가 사용하는 환경 변수만을 변경할 수 있을 뿐, 자신이 생성하는 자식프로세스에게 전달되는 환경변수값은 변경할 수 없다.

### 5.10.6 현재 작업 디렉토리

모든 프로세스는 자신이 실행되고 있는 위치, 화일의 상대적인 주소를 계산할 위치를 가지고 있는데, 이를 현재 작업 디렉토리라고 한다. 일반적으로 터미널을 통해서 프로그램이 실행될 때, 해당 프로세스의 현재 디렉토리는 프로세스가 실행되었던 시점의 터미널의 현재 디렉토리로 설정된다. 또한 부모 프로세스가 fork()를 통해서 자식 프로세스를 생성하는 경우에는 자식 프로세스의 맨 처음 현재 디렉토리는 부모 프로세스가 자신을 생성했던 시점의 현재 디렉토리로 설정된다.

프로세스의 현재 작업 디렉토리는 chdir() 시스템 콜을 통해서 변경할 수 있다. 이는 해당 프로세스의 현재 디렉토리만을 변경할 뿐, 해당 프로세스를 실행시킨 터미널이나 부모 프로세스의 현재 디렉토리를 변경시키지는 않는다.

### 5.10.7 현재 루트 디렉토리

프로세스는 또한 화일의 절대 경로를 계산하는 기준 위치인 루트 디렉토리를 관리한다. 현재 작업 디렉토리와 마찬가지로 프로세스가 생성될 때는 자신을 실행시킨 부모 프로세스의 루트 디렉토리로 설정된다. 이 루트 디렉토리 또한 다음과 같은 시스템 콜을 통해서 변경할 수 있다.

```c
#include <unistd.h>

int chroot(const char * path);
```

함수 호출이 성공적으로 이루어지면, 앞으로 화일의 절대 경로를 계산할 때 `/` 디렉토리가 `path` 에 대응하게 된다. 다만 이 시스템 콜은 현재 프로세스의 루트 디렉토리만을 변경할 뿐, 화일 시스템의 루트 디렉토리를 변경하는 것은 아니다. 함수 호출에 실패할 경우 -1을 반환한다.

### 5.10.8 사용자 식별번호와 그룹 식별번호

프로세스에는 그 프로세스를 실제로 실행시킨 사용자와 그 사용자가 포함된 그룹의 정보가 저장되어 있다. 프로세스를 실제로 실행시킨 사용자는 사용자 식별번호(ruid)로, 그 사용자가 포함된 그룹은 그룹 식별번호(rgid)로 확인할 수 있다.

이보다 더 중요한것은 유효 사용자 식별번호(euid)와 유효 그룹 식별번호(egid)이다. 이는 프로세스가 파일을 접근할때, 파일에 설정된 사용자에 대한 허가(permission)에 프로세스가 부합하는지에 대해 비교할때 기준이 된다.

이러한 식별번호는 getuid, geteuid, getgid, getegid 함수로 얻어낼 수 있다.

```c
void main()
{
    uid_t uid, euid;
    gid_t gid, egid;

    uid = getuid();
    euid = geteuid();

    gid = getgid();
    egid = getegid();
}
```

또한 setuid, setgid 함수를 통해서 프로세스의 유효 식별번호를 설정할 수도 있다.

```c
void main()
{
    uid_t newuid;
    gid_t newgid;
    ...

    status = setuid(newuid);
    status = setgid(newgid);
}
```

일반적인 사용자의 경우 유효 사용자 식별번호와 유효 그룹 식별번호로 진짜 사용자 식별번호와 그룹 식별번호로만 설정 가능하다. 다른 사용자의 식별번호로 설정하는 것은 수퍼유저만이 가능하다.

### 5.10.9 파일 크기 제한 : ulimit

프로세스가 생성하는 파일의 크기에는 제한이 있다. 이러한 제한은 다음과 같은 시스템 호출을 통해서 조작될 수 있다.

```c
#include <unistd.h>
#include <sys/types.h>

long ulimit(int cmd, [long newlimit]);
```

현재 파일의 크기 제한을 얻으려면 cmd 인자에 UL_GETFSIZE를 전달한다. 그러면 파일 크기 제한이 512바이트 블록단위로 반환된다.

파일의 크기 제한을 변경하려면 cmd 인자에 UL_SETFSIZE를 전달하고, newlimit에는 새로운 파일 크기 제한을 512 바이트 블록단위로 전달한다.

오직 수퍼유저만이 파일제한 크기를 늘릴 수 있다. 파일 소유자의 식별번호를 effective user id로 갖는 프로세스는 파일 크기 제한을 줄이는 것만 허용된다.

### 프로세스 우선 순위 : nice

프로세스가 스케줄링 될 때, 다른 프로세스보다 부분적으로 더 많이 실행될 수 있다. 이러한 실행시간의 차이는 프로세스에 부여된 nice 값에 기반한다. 더 낮은 nice 값을 가진 프로세스가 cpu 자원에 대해서 더 높은 우선순위를 갖는다.

이러한 nice값은 nice() 시스템 콜을 통해서 변경할 수 있다. 인자로 전달하는 값은 이 nice 값의 증가분이다. 오직 수퍼유저만이 이 인자로 음수를 전달할 수 있으며, 다른 사용자는 양수값을 전달하여 다른 프로세스에게 자원을 양보할 수만 있다.
