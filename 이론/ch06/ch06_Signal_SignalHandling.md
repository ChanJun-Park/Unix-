# Ch06 시그널과 시그널 처리

## 6.1 서론

다음과 같이 매우 긴 시간이 필요한 명령이 터미널에서 실행되는 상황을 가정해보자.

```bash
$cc very_big_program.c
```

이 명령이 실행되는 중간에 프로그래머가 미리 오류를 발견하고 cc 명령이 결국 실패할 것임을 인지한다면, `ctrl + c`를 입력하여 cc 명령을 중지시킬 수 있다. 키보드 입력을 제어하는 커널은 `ctrl + c` 키가 입력되었음을 인지하고, 현재 터미널에서 실행되고 있는 프로세스들에게 signal을 보내 **인터럽트** 한다. **시그널**은 커널이나 프로세스가 다른 프로세스에게 보내는 일종의 **신호** 또는 **메시지**이다.

한 프로세스는 시그널에 관하여 다음 세 가지 일을 할 수 있다.

- 자신이 특정 시그널을 받을 때 응답할 방법을 선택한다(시그널 핸들링).
- 중대한 코드의 지정된 부분을 수행할 동안 시그널을 봉쇄한다(시그널을 뒤로 미룬다).
- 다른 프로세스에 시그널을 보낸다.

### signal concepts

시그널은 **소프트웨어 notification**이다. 시그널을 발생시키는 이벤트가 나타났을 때 **generated** 된다고 표현한다. 프로세스가 해당 시그널에 대한 action을 취한 경우 시그널이 **delivered** 되었다고 한다. generation과 delivery 사이 간격이 시그널의 **lifetime**이다. generation되었지만 delivered 되지 못한 시그널을 **pending** 상태에 있다고 표현한다.

### 6.1.1 시그널 이름

`signal.h` 헤더 파일에는 여러가지 시그널에 대한 정의가 있다. 시그널의 정의는 `#define`을 이용해서 선언된 기호 상수이다. 유닉스에서 제공하는 시그널 이름들은 대부분 커널에서 사용하기 위한 것이다. 물론 한 프로세스로부터 다른 프로세스로 보내기 위한 것도 약간 제공된다.

- SIGABRT : 프로세스 중단(abort) 시그널. 현행 프로세스가 abort() 시스템 콜을 호출할 때 발생한다. XSI에서 비정상적 종료라고 기술하고 있는 결과를 낳는다. UNIX에서 실제 효과는 코어 덤프(디버깅을 위해 프로세스 이미지를 디스크 화일로 덤프)이다.
- SIGALRM : 프로세스 내부에서 설정한 타이머가 종료되었을 때 발생하는 시그널이다.
- SIGBUS : 버스 오류. 하드웨어 오류 탐지시 발생. 비정상적 종료(코어덤프) 발생.
- SIGCHLD : 자식 프로세스가 종료되거나 중단 되었을 때 발생하는 시그널이다. 부모 프로세스에게 시그널이 전달된다. 부모프로세스는 디폴트로 이 시그널을 무시한다.
- SIGCONT : 만일 중단됐을 경우 실행을 계속하라.
- SIGFPE : 부동소수점 오류, 오버플로우, 언더플로우와 같은 오류를 발생시키는 계산을 수행할때 나타나는 시그널이다. 비정상적 종료 발생.
- SIGHUP : 전화 끊기 시그널. 제어 단말기의 연결이 끊어졌거나, 제어 단말기와 연관된 세션의 리더가 퇴장할 때 그 제어 단말기에 연결되어 있는 모든 프로세스, 세션에 속하는 모든 프로세스에게 보내진다.
- SIGILL : 유효하지 않은 명령을 실행시키려고 시도하는 경우 발생하는 시그널이다. 비정상적 종료.
- SIGINT : 인터럽트. 사용자가 인터럽트 키를 누르면 커널에 의해서 제어 단말기 세션과 연관된 모든 프로세스에게 보내진다.
- SIGKILL : 한 프로세스가 다른 프로세스를 종료시키기 위해 보내는 특별한 시그널이다. 이것은 무시되거나 포착될 수 없다.
- SIGPIPE : 수신인이 종료한 파이프나 소켓에 쓰기.
- SIGPROF : 프로파일 시간 만료.
- SIGQUIT : 중지. SIGINT와 매우 비슷하다. 사용자가 단말기에 대해서 중지에 해당하는 키( `Ctrl + \` )를 칠 때 단말기와 연관된 모든 프로세스에게 보내진다. 비정상적인 종료를 초래한다.
- SIGSEGV : 잘못된 메모리 주소에 접근하려 할 때 발생하는 시그널이다. 비정상적인 종료를 초래한다.
- SIGSTOP : 수행을 중단하라. 이것은 작업 제어 시그널로 프로세스를 중단시킨다. 이것은 포착되거나 무시될 수 없다.
- SIGSYS : 무효인 시스템 호출.
- SIGTERM : 프로세스를 종료시킬 것을 의미하는 시그널이다. SIGKILL과는 다르게 무시되거나 포착 될 수 있다.
- SIGTRAP :
- SIGTSTP : 단말기 중단 시그널. 사용자가 일시중지(`Ctrl + Z`) 키를 입력할 경우 발생한다. SIGSTOP과 비슷하지만, 이것은 무시되거나 포착될 수 있다.
- SIGUSR1, SIGUSR2 : 사용자 지정 시그널. 사용자가 원하는 임의의 목적으로 사용할 수 있다.

## 6.2 시그널 처리

한 프로세스에게 전달된 시그널에 대해서 프로세스가 이 시그널을 처리하는 방법은 3가지가 있다.

- Default action : 시그널에 대한 **기본 action을 수행한다.** 대부분의 시그널에 대해서 프로세스의 기본 action은 프로세스 종료이다. 그러나 SIGUSR1, SIGUSR2의 기본행동은 무시이다. 또한 SIGSTOP의 기본 행동은 프로세스 중지이다.
- Ignore action : 해당 **시그널을 무시한다.**
- User-defined action : 사용자가 정의한 **시그널 핸들러를 실행시킨다.** 이렇게 하기 위해선 먼저 커널에 시그널 핸들러를 등록(install)해야 한다. 사용자 프로그램이 실행되는 도중에 시그널 핸들러가 정의된 시그널이 들어오는 경우, 실행되고 있던 부분에서 인터럽트 되어 바로 시그널 핸들러 부분이 실행된다. 시그널 핸들러가 처리된 이후에는 원래 실행하던 부분으로 복귀한다.

### 6.2.0 과거의 시그널 처리

#### signal system call

```c
void (*signal(int signo, void (*func)(int)))(int);
```

signal 함수는 signo에 해당하는 시그널에 대해서 2번째 인자로 넘겨주는 함수 포인터를 시그널 핸들러로 등록시키는 함수이다. 해당 시그널에 대한 핸들러가 전에 존재했다면, 그 시그널 핸들러에 대한 함수 포인터가 반환된다.

signal() 함수는 요즘에는 쓰이지 않는다. signal() 함수가 존재하는 이유는 과거의 유닉스 구현에 대한 하위 호완성을 제공하기 위함이다. 최신 application은 sigaction 시스템 호출을 통해서 시그널 처리를 해야한다.

#### Signal block

Signal은 생성된 다음 바로 프로세스에 보내지지 않고, 일정 시간 동안 보내지기를 기다리게 될 수도 있다. 이런 현상을 시그널이 block 되어 있다고 표현한다. 프로세스는 process signal mask라는 값을 관리한다. 이는 프로세스가 일정 시간동안 블로킹할 시그널들을 관리한다.

프로그래머가 포착하도록한 시그널이 시그널 핸들러에 의해 처리되기 전에 해당 시그널에 대한 정보가 process signal mask에 등록된다. 또한 시그널 핸들러 수행이 완료되면 다시 해당 시그널이 process signal mask에서 제거된다. 이는 시그널 핸들러 수행시 동일한 시그널에 의해 시그널 핸들러가 인터럽트 되는 것을 방지한다.

process signal mask에 의해 블로킹 되는 시그널들은 큐와 같은 구조에 저장되지 않는다. 가장 마지막에 보내진 시그널만 블로킹 상태가 끝났을 때 프로세스에 전달된다. 이와 같은 성질 때문에 시그널을 프로세스간의 통신 매체로 사용하기가 힘들다.

#### Signal handling & exec

**fork** 에 의해서 생성된 자식 프로세스는 부모 프로세스의 시그널 핸들러를 상속받는다. 그러나 자식 프로세스가 **exec** 함수 호출을 통해서 새로운 프로세스로 바뀐 뒤에는 시그널 핸들러가 상속되지 않는다. 이 프로세스는 기존과는 완전히 다른 메모리 구조를 가지고 있어 시그널 핸들러 주소가 무의미하기 때문이다.

### 6.2.1 시그널 집합

시그널 처리 방법을 알아보기 전에 시그널 처리에서 자주 사용하는 데이터 타입인 `sigset_t`에 대해서 알아보자. `sigset_t`은 여러가지 시그널의 집합을 표현한다. `sigset_t`는 시스템에 정의되어 있는 모든 시그널을 포함 할 수 있을 정도로 큰 것이 보장되어 있다.

앞으로 사용할 시그널 처리 함수에 이 시그널 집합을 전달하면서 시그널 집합에 들어있는 시그널들에 대해서 특정한 처리를 진행할 수 있다. 대표적으로 프로세스 시그널 마스크가 있다. 프로세스가 실행하는 동안 프로세스 시그널 마스크에 설정되어 있는 시그널들은 블로킹된다.

`sigset_t`를 설정할 수 있는 함수들은 다음과 같은 것들이 있다.

```c
#include <signal.h>

/* 초기화 */
int sigfillset(sigset_t *set);
int sigemptyset(sigset_t *set);

/* 조작 */
int sigaddset(sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);
```

sigset_t를 설정하기 위해서는 sigfillset이나 sigemptyset 중 하나는 반드시 실행해주어야 한다.

### 6.2.2 시그널 행동을 지정 : sigaction

signal을 대체해서 많이 사용하는 것이 sigaction 함수이다. sigaction을 이용하여 한 시그널을 취급할 특정 방법을 선택할 수 있다.

```c
#include <signal.h>

int sigaction(int signo, const struct sigaction *act, struct sigaction *oact);
```

- signo : 행동을 지정할 시그널 번호. sigaction이 효과를 가지려면 반드시 해당 시그널이 발생하기 전에 sigaction을 호출해야 한다. 어떠한 시그널도 전달할 수 있지만, SIGKILL과 SIGSTOP만은 예외이다.
- act : 시그널에 대해서 지정하고 싶은 행동을 나타낸다.
- oact : 시그널에 대해서 이전에 지정했던 행동 정보를 oact에 저장한다. 이전 정보를 복원하고 싶을 때 사용할 수 있다.

`sigaction` 구조체는 다음과 같이 정의되어 있다.

```c
struct sigaction {
    void (*sa_handler)(int);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_sigaction)(int, siginfo_t, void *);
}
```

- sa_handler는 관련된 시그널이 발생했을 때 수행되는 행동을 나타낸다. 3가지 값이 설정될 수 있다.
  - SIG_IGN : 해당 시그널을 단순히 무시한다.
  - SIG_DFL : 해당 시그널에 대한 디폴트 행동을 수행한다.
  - 시그널 핸들러 주소 : 해당 시그널이 전달되었을때 인터럽트되어 실행될 함수의 이름을 지정할 수 있다.
- sa_mask는 시그널 핸들러가 실행되는 도중에 블로킹 시킬 시그널 집합을 의미한다. 이것은 시그널이 사라진다는 것이 아니다. 처리함수가 완료될 때까지 보류 상태가 된다는 것이다. 포착된 signo에 대한 시그널 핸들러가 실행될때 해당 시그널 역시 현재 시그널 마스크에 포함된다.
- sa_flags는 지정된 시그널에 대한 행동을 변경하는 데 사용할 수 있다. sa_flags 값을 SA_RESETHAND로 설정하면, sa_handler 에 저장되어 있던 사용자 정의 함수가 실행된 뒤, sa_handler 값을 SIG_DFL로 다시 설정하게 한다. sa_flags 값을 SA_SIGINFO로 설정하면 시그널 핸들러를 호출할 때 추가 정보를 전달한다. 이 경우 sa_handler는 쓸모가 없으며 마지막 필드 sa_sigaction이 실행된다. 전달되는 정보는 signo, 보내는 프로세스의 pid, ruid 등등이다.
- sa_sigaction은 sa_handler를 대신해서 호출될 수 있는 시그널 핸들러이다. sa_flags 값을 SA_SIGINFO 로 설정하면 sa_handler 대신 시그널 핸들러로 실행된다.

### 6.2.3 시그널과 시스템 호출

대부분의 경우에 프로세스에 시그널이 전달될 때, 시스템 호출이 진행중인 경우 시스템 호출은 시그널 핸들러에 의해서 인터럽트 되지 않는다. 그러나 매우 긴 시간이 소모될 수 있는 시스템 호출의 경우(read(), write(), fgets() 등등 영원히 blocking 될 수 있는 시스템 호출) 시그널 핸들러에 의해서 인터럽트 되고, -1을 반환하게 된다(errno도 EINTR로 설정된다).

sigaction 구조의 sa_flags 값을 SA_RESTART값으로 설정하면 시스템 호출이 시그널 핸들러에 의해 인터럽트 되었을 때, 시그널 핸들러 호출이 끝나고 나서 인터럽트된 시스템 호출을 자동으로 재시작하게 한다.

UNIX 시그널은 쌓이지 않는다. 어느 한 순간에 프로세스에서 처리되지 않는 시그널은 시그널 종류별로 하나만 관리된다.

### 6.2.4 sigsetjmp, siglongjmp

가끔 시그널을 받았을 때 프로그램의 특정위치로 이동하는 것이 합리적일 때가 있다. (사용자가 특정 인터럽트 키를 입력하면 프로그램의 주메뉴로 이동하기 등등...) 이를 위해서 sigsetjmp와 siglongjmp를 사용할 수 있다. sigsetjmp는 현재 프로그램의 스택 상태를 저장함으로써 현재 프로그램의 위치와 시그널 마스크를 저장한다. siglongjmp는 저장된 위치로 제어를 전달한다. siglongjmp는 일종의 장거리 goto이다. siglongjmp 는 스택의 상태를 파괴하고 이전 스택 상태를 복원한다. 따라서 siglongjmp 호출 후 siglongjmp는 복귀하지 않는다. 실제로 복귀되는 부분은 sigsetjmp이다.

```c
#include <setjmp.h>

/* 프로그램내의 위치를 저장한다. */
int sigsetjmp(sigjmp_buf env, int savemask);

/* 저장된 위치로 되돌아 간다 */
void siglongjmp(sigjmp_buf env, int val);
```

프로그램의 위치가 저장되는 부분은 `sigjmp_buf env`이다. `sigsetjmp` 호출에서 전달한 `env`에 스택 정보를 저장하게 된다. `sigsetjmp` 두번째 인자인 savemask에 0이 아닌 값을 전달하면 그 시점에서의 시그널 마스크값 역시 저장된다. `siglongjmp`에서는 미리 저장한 env 값 중 하나를 전달하면 해당 env를 설정한 `sigsetjmp` 위치로 복귀된다. `siglongjmp` 호출에서 2번째 인자로 전달한 값이 이동한 `sigsetjmp`의 반환값으로 나온다. 최초에 `sigsetjmp`를 호출할 때는 0이 반환된다.

> 사용 예시

```c
#include <sys/types.h>
#include <signal.h>
#include <setjmp.h>
#include <stdio.h>
sigjmp_buf position;

void goback(void);

int main() {
    static struct sigaction act;


    /* 현재 위치를 저장한다. */
    if (sigsetjmp(position, 1) == 0) {
        act.sa_handler = goback;
        sigaction(SIGINT, &act, NULL);
    }

    // do something


}

void goback(void) {
    fprintf(stderr, "\nInterrupted\n");
    siglongjmp(position, 1);
}
```

## 6.3 시그널 봉쇄(blocking)

앞서 sigaction에서 잠깐 언급했듯이 프로세스로 들어오는 시그널들은 봉쇄(blocking)될 수 있다. 프로세스가 데이터베이스 갱신과 같은 민감한 작업을 수행될때는 시그널과 같은 요소의 방해를 받지 않는 것이 좋다. 프로세스가 실행되는 동안 blocking 시킬 시그널들은 sigprocmask 함수를 통해서 설정할 수 있다.

```c
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
```

첫번째 인자 how는 어떤 행동을 취할 것인지를 결정한다.

- SIG_SETMASK : 두 번째 인자로 전달한 set에 설정된 시그널들을 지금부터 blocking
- SIG_UNBLOCK : 두 번째 인자로 전달한 set에 설정된 시그널들을 마스크에서 제거
- SIG_BLOCK : 두 번째 인자로 전달한 set에 설정된 시그널들을 마스크에 추가

## 6.4 시그널 보내기

### 6.4.1 다른 프로세스에게 시그널 보내기 : kill

커널 뿐만 아니라 프로세스도 시그널을 보낼 수 있다. 이렇게 보내진 시그널은 소프트웨어 인터럽트 역할을 하게 된다. 다음 **kill** 함수를 통해서 프로세스로 시그널을 전송할 수 있다.

```c
#include <signal.h>
#include <sys/types.h>

int kill(pid_t pid, int signo);
```

kill 함수는 pid 인자로 지정한 프로세스에 시그널을 전송한다. raise 함수는 자기 자신 프로세스에게 시그널을 전송한다.

kill 함수를 통해 다른 프로세스에게 시그널을 보낼때 특권과 관련된 문제가 있다. 시그널을 보내는 프로세스의 진짜 사용자 식별번호 또는 유효 사용자 식별번호와 받는 프로세스의 진짜 또는 유효 사용자 식별번호가 일치해야 한다. 만약 이러한 조건을 만족하지 않는 프로세스에게 시그널을 보내기 위해서 kill 함수를 호출하면 이 호출은 실패하여 -1을 반환하고, errno에는 EPERM 이 설정된다.

kill 함수의 `pid`에 어떤 값이 들어가느냐에 따라서 kill 함수의 동작을 변경할 수 있다.

- 양의 정수 : 숫자에 해당하는 pid 값을 갖는 프로세스에게 시그널 전달
- 0 : kill을 호출하는 프로세스와 동일한 그룹에 속한 모든 프로세스에게 시그널 전달. 보내는 자기 자신도 포함
- -1이고 유효 사용자 번호가 수퍼 유저가 아닌 경우 : 진짜 사용자 식별번호가 보내는 프로세스의 유효 사용자 식별번호와 동일한 모든 프로세스에게 시그널 전달. 보내는 프로세스 포함.
- -1이고 유효 사용자 번호가 수퍼 유저인 경우 : 특수한 시스템 프로세스를 제외한 모든 프로세스에게 시그널 전달.
- -1이 아닌 음의 정수 : 숫자의 절대값에 해당하는 그룹 id를 갖는 모든 프로세스에게 시그널 전달. 보내는 프로세스 포함

### 6.4.2 자산에게 시그널 보내기 : raise와 alarm

raise 함수는 단순히 자기 자신에게 시그널을 보낸다.

```c
#include <signal.h>

int raise(int sig);
```

alarm 함수는 인자로 지정한 시간이 지난 뒤 SIGALRM 시그널이 생성되도록 한다.

```c
#include <unistd.h>

unsigned int alarm(unsigned int secs);
```

시간은 초단위로 설정된다. alarm은 sleep과는 달리 blocking되지 않고 알람이 울리기 전까지 다른 일들을 수행할 수 있다. 작동중인 알람시계는 exec를 호출하더라도 계속해서 작동한다(fork를 통해 생성한 자식 프로세스에 상속되지는 않는다).

**alarm(0)** 는 이전에 설정한 alarm 을 끄는 역할을 한다. 이런 식으로 프로세스에서는 일종의 타이머를 관리할 수 있다. 그런데 이런 타이머는 프로세스당 하나만 생성될 수 있다. alarm 함수 호출시에 이전에 설정된 타이머가 존재한다면 alarm 함수는 이전 타이머의 남은 시간을 반환하게 된다.

```c
#include <unistd.h>

int pause(void);
```

alarm 함수의 단짝으로 **pause** 함수를 사용할 수 있다. pause 함수는 프로세스에 임의의 시그널이 들어올 때까지 프로세스의 실행을 멈춘다. 프로세스가 들어온 시그널에 대해 정상종료를 수행하면 pause에 관계없이 정상 종료된다. 또한 들어온 시그널을 무시하면 pause도 시그널을 무시한다. 그런데 프로세스가 포착하는 시그널이 들어오면 해당 시그널에 대한 핸들러가 모두 실행된 이후 pause는 -1을 반환하고, errno에 EINTR을 저장한다.
