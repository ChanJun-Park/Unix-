# Ch08 고급 IPC 설비

## 8.2 Advanced Interprocess Communication

유닉스 시스템은 여러가지 Interconnection Process Communication 기능을 만들어서 프로그래머가 다양한 프로세스 통신 기능을 사용할 수 있도록 한다. 7장에서 배운 파이프와 FIFO와 함께 메시지큐, 세마포어, 공유 메모리가 IPC 기능을 위해 제공되고 있다.

### 8.2.1 서론 및 소개

메시지큐, 세마포어, 공유 메모리는 내부 구현 코드의 유사성을 반영하여 이들을 사용하는 함수 또한 유사한 형태로 정의되어 있다.

![1](image/1.png)

메시지큐, 세마포어, 공유 메모리를 사용하기 위해서는 먼저 이들을 unique하게 식별할 IPC 설비 키가 있어야 한다. IPC 설비 키는 파일의 이름과 유사하게 해당 IPC 설비를 유일하게 식별해준다. 이러한 key를 위해서 `key_t` 타입이 정의되어 있다. 파일 이름과 유사한 점이 있지만, IPC 설비들은 시스템 전체에서 한번에 관리되기 때문에 디렉토리 경로 지정을 통해서 동일한 이름을 부여할 수 있는 파일이름과는 약간의 차이점이 있다. 이와같은 특징 때문에 IPC 설비 키를 unique하게 설정하는 것이 중요한데, 다음과 같은 함수의 도움을 받을 수 있다.

```c
key_t ftok(const char *pathname, int id);
```

위 함수는 특정 파일 경로와 연관된 유일한 IPC 설비키를 반환해준다. 파일의 경로는 시스템에서 유일하게 식별할 수 있다는 특성을 이용해서, 이 파일 경로 이름을 **seed 값** 삼아 IPC 설비키를 반환해준다고 생각하면 된다. 두번째 인자로 전달한 id도 일종의 seed 역할을 한다고 생각하면 된다.

만약 파일이 지워지고, 동일 경로 이름의 파일이 새로 생성되는 경우 ftok함수는 다른 값을 반환할 것이다. ftok 함수는 인자로 전달한 파일에 IPC 설비를 사용할 경우나, 해당 파일이 영구적으로 보존되는 경우 사용할 수 있다.

이러한 IPC 설비 키를 이용하여 IPC 설비들을 생성하면 IPC 설비 식별자라는 것이 생성된다. 이는 파일을 open하는 경우 반환되는 file descriptor와 유사하다. 그러나 차이점이 존재하는데, file descriptor가 해당 파일을 열었던 프로세스에서 유일하다면, IPC 설비 식별자는 전체 시스템에서 유일하며, 또한 여러 프로세스에서 사용될 수 있다.

IPC 설비들을 조작하는 함수는 2가지로 나뉠 수 있다. IPC 설비를 제어하는 함수와, 각각의 IPC 설비들에만 존재하는 함수가 그것이다. 파일의 stat 구조와 같이 IPC 설비들에도 해당 설비들에 관한 정보를 저장하는 구조가 있다. 이 구조에는 IPC 설비의 허가와 관련된 멤버도 존재하는데, 이 멤버는 ipc_perm 형태로 식별할 수 있다. 다시 ipc_perm 멤버는 다음과 같은 멤버들로 구성된다.

- c_uid
- c_gid
- euid
- egid
- perm

이들 멤버는 IPC 설비의 접근 제한에 대한 기준이 된다. perm은 파일의 permission과 동일한 역할을 한다. 다만, 이 perm은 파일과는 다르게 사용자 mask값에 영향을 받지 않는다. 또 다른 점은 IPC 설비의 실행권한은 아무런 효과도 의미로 갖지 않는다.

### 8.2.2 메시지큐

이제 메시지큐부터 시작하여 본격적으로 IPC 설비들의 사용법을 알아보자. 메시지큐는 프로세스들간의 메시지 교환을 가능하게 해주는 설비이다. 메시지는 대체로 문자열, 문자 데이터 바이트들을 의미한다. 하나의 프로세스가 문자열을 메시지큐에 넣으면 다른 프로세스가 해당 메시지큐에서 메시지를 읽어 사용할 수 있다. 이는 파이프에서 제공하는 서비스와 유사함을 알 수 있다.

메세지큐를 사용하기 위해서는 우선 메시지큐를 만들어야 한다. 다음과 같은 함수를 이용하여 메시지큐를 만들 수 있다.

#### msgget

```c
int msgget(key_t msqkey, int flag);
```

- 인자
  - msqkey : 메시지큐를 식별하는 메시지큐 설비 키
  - flag : 허가모드와 실행방식 설정
- 반환값
  - 메시지큐 식별자 (음이 아닌 정수)
  - 실패시 -1

`msgget` 함수의 동작은 다음과 같다. 만약 인자로 전달한 msqkey 의 설비 키를 가지고 있는 메시지큐가 이미 존재한다면 해당 메시지큐에 대한 메시지큐 식별자가 반환된다. 만약 msqkey에 해당하는 메시지큐가 없다면, flag 조건값에 따라서 새로운 메시큐를 생성하거나, 함수 호출에 실패하게 된다. flag에 전달할 수 있는 값은 다음과 같다.

- MSG_CREAT : 새로운 메시지큐 생성
- MSG_EXCL : 이 플래그가 MSG_CREAT과 함께 전달되는 경우, msgkey에 해당하는 메시지큐가 있다면 함수 호출에 실패하고, 없는 경우에만 새로운 메시지큐를 생성하고 식별자를 반환한다.
- mode : 메시지큐에 대한 허가모드

> 예시

```c
int id = msgget((key_t)0105, MSG_CREAT | MSG_EXCL | 0660);
```

생성된 메시지큐를 사용하는 두 함수는 다음과 같은 형태로 정의되어 있다.

```c
int msgsend(int mqid, const void * message, size_t len, int flag);
int msgrecv(int mqid, void * message, size_t len, long type, int flag);
```

#### msgsend

- 인자
  - mqid : 메시지큐 식별자
  - message : 전달할 메시지가 담긴 사용자 정의 타입 변수의 주소
  - len : 전달할 메시지의 문자열 길이
  - flag : 함수 동작 지정 플래그
- 반환값 : 성공시 0, 실패시 음수

사용자는 메시지를 전달하기 위해서 먼저 자신의 메시지에 대한 타입을 정의해야 한다. 다음과 같은 형태로 정의될 수 있다.

```c
struct my_message {
    long mtype;
    char * message[MAXNUM];
}
```

message는 실제로 메시지를 넘길 사용자가 전달한 문자열을 담을 배열이고, MAXNUM은 가변적일 수 있다. mtype은 메시지의 타입을 결정한다. 이는 후에 msgrecv 함수의 4번째 인자와 일치하는 메시지만을 받아낼때 사용할 수 있다.

이 함수의 4번째 인자는 특정 조건에서의 msgsend 함수의 동작을 설명한다. 이 플래그에 **IPC_NOWAIT**가 설정된 경우 msgsend는 특정상황에서 block 되지 않고 바로 리턴한다. msgsend가 block될 수 있는 특정상황은 메시지큐에 담긴 메시지크기가 시스템 전체 허용량보다 커졌거나, 단일 메시지큐에 담을 수 있는 메시지 개수의 제한에 도달할 경우다. IPC_NOWAIT 값 설정시 msgsend 함수는 블럭되지 않고 -1을 곧바로 반환한다(errno 값에는 EAGAIN).

#### msgrecv

- 인자
  - mqid : 메시지큐 식별자
  - message : 메시지를 담아올 사용자 정의 타입의 변수 주소
  - len : 담아올 메시지의 최대크기
  - type : 이 인자로 전달한 타입과 일치하는 메시지큐의 맨 처음 저장된 메시지가 반환된다.
  - flag : 함수 동작 지정 플래그
- 반환값 : 성공시 0, 실패시 음수

이 함수의 5번째 인자인 flag는 msgsend에서와 같이 함수의 실행 동작을 명세한다. 이 값에 **IPC_NOWAIT** 는 앞서 설명한대로 msgrecv가 block 될 수 있는 상황에서 block되지 않게 한다. msgrecv 함수는 메시지큐에 아무런 메시지가 없는 경우 block 된다. IPC_NOWAIT값 설정시 -1을 반환한다(errno 값에는 EAGAIN). flag값에 **MSG_NOERROR**라는 값을 설정할 수도 있다. 이는 msgrecv 함수에 설정한 len 값보다 메시지큐에 저장된 메시지의 길이가 긴 경우 함수 호출이 실패하지 않고 읽을 수 있는 길이만큼만 잘라서 저장하게 한다(원래는 -1을 호출하여 실패한다).

이번에는 메시지큐 관련 정보를 읽고, 수정할 수 있는 함수에 대해서 알아보자.

#### msgctl

```c
int msgctl(int mqid, int command, )
```
